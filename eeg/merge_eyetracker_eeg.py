#%%
import mne
import re
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import glob
import os
import meegkit
from mne.datasets import sample
from mne.stats.regression import linear_regression_raw
from scipy.interpolate import CubicSpline, interp1d

# % Load EEG and align it to eyetracker data
# %------------------------------------------

# % eyetracker timestamps are milliseconds measured from the time when the tracker software was started
# % eeg timestamps are sample number but the sampling rate is 1000Hz here so
# % no conversion necessary. **warning** IF reusing this script, you will need to be
# % cautious about wehther you are using time in sample or in milliseconds
# % and convert where appropriate.

# % Load preprocessed data from MNE-python
# % - this data has been cleaned using EEGanalysis/prepro.py:
# %   robust detrending, DSS_based line
# %   noise removal, and has events labelled from the trial log file.

##load eeg from fif
dir_raw = '/Volumes/Blue1TB/EyeMindLink/Data'
dir_fif = '/Volumes/Blue1TB/EEG_processed/preprocessed_fif/'
dir_events = os.path.expanduser('~/Emotive Computing Dropbox/Rosy Southwell/EyeMindLink/Processed/events/')
fn_base = '_p.fif'
GAZE_SRATE = 1000  # eyetracker sample rate

##load reparsed fixations df for all subjects
fix_df = pd.read_csv('../info/FixationReport+InboundSaccades.csv')  # this file is generated by gaze/wrangle_fix_sac_reports.py
fix_df['pID'] = fix_df['RECORDING_SESSION_LABEL'].str.split('-').str[0]
fix_df=fix_df.rename(columns={'CURRENT_FIX_INTEREST_AREA_ID':'IA_ID', 'CURRENT_FIX_INTEREST_AREA_LABEL':'IA_LABEL','CURRENT_FIX_PUPIL':'fix_pupilAvg', 'CURRENT_FIX_START':'latency_samples','CURRENT_FIX_DURATION':'duration_samples', 'CURRENT_FIX_INDEX':'fix_pageIndex','CURRENT_FIX_X':'fix_xAvg','CURRENT_FIX_Y':'fix_yAvg'})
fix_df['eye'] = fix_df['EYE_USED'].apply(lambda x: 'L' if x == 'LEFT' else 'R')
ia_df = pd.read_csv('../info/ia_label_mapping_opt_surprisal.csv')
beh_df = pd.read_csv('~/Emotive Computing Dropbox/Rosy Southwell/EyeMindLink/Processed/Behaviour/EML1_page_level.csv')
eeg_trigger_df = pd.read_csv('../info/EEGtriggerSources.csv')

##get subject list
# # subj mathes EML1_XXX_p.fif
# pIDs = [re.findall(r'EML1_\d{3}', f)[0] for f in os.listdir(dir_fif) if f.endswith(fn_base)]
# # unique and sort
# pIDs = sorted(list(set(pIDs)))
# exclude = [20, 21, 22, 23, 24, 25, 26, 27, 31, 39, 40, 73, 77, 78, 87,88,93,99, 110,115,123,125, 138, 160, 164,167,168, 170,171,172,173, 175,176,177, 178,179] # ubj to exclude because no eeg or no trigger etc.
# pIDs = [p for p in pIDs if int(re.findall(r'\d{3}', p)[0]) not in exclude]
pIDs = [170,175, 176, 177]
pIDs = [f'EML1_{p:03d}' for p in pIDs]
# pIDs = pIDs[pIDs.index('EML1_180'):]# restart from

#%%
for pID in pIDs:
    print(pID)
    # # check there are triggers for this subject
    # if eeg_trigger_df.loc[eeg_trigger_df['pID']==pID,'sdcard'].values[0]==0 and eeg_trigger_df.loc[eeg_trigger_df['pID']==pID,'streamed'].values[0]==0:
    #     print(f'No triggers for {pID}')
    #     continue    
    raw_file = os.path.join(dir_fif, f'{pID}_p.fif')
    EEG = mne.io.read_raw_fif(raw_file, preload=True)


    ##Read info txt to determine whether EEG+triggers are from SD card (default) or streamed (backup)
    info_file = os.path.join(dir_fif, f'{pID}-info.txt')
    with open(info_file, 'r') as file:
        triginfo = file.read()

    ##Read events.csv for triggers and descriptions
    events_file = os.path.join(dir_events, f'{pID}_events.csv')
    logtrig = pd.read_csv(events_file).rename(columns={'EVENT': 'identifier','ParticipantID':'pID'})
    # Copy the correct EEG sample column for use depending on triginfo
    try:
        if 'LA0' in triginfo:
            logtrig['eeg_sample'] = logtrig['eegSD_sample_est']
        else:
            logtrig['eeg_sample'] = logtrig['eeg_sample_est']
    except:
        print(f"no useable EEG trigger info for {pID}")
        continue


    ##merge w behavioural data etc
    # thisbeh = beh_df[beh_df['ParticipantID']==pID]
    # thisbeh['task'] = 'reading'
    # logtrig = logtrig.merge(thisbeh, on=['task', 'Text', 'PageNum'], how='left')
    logtrig['task'] = 'other'
    logtrig['event_type'] = 'task_begin'
    logtrig.loc[logtrig['VAL']==7, 'task'] = 'reading'
    logtrig.loc[logtrig['VAL']==20, 'task'] = 'sham'
    logtrig.loc[(logtrig['VAL']>=12) & (logtrig['VAL']<=15), 'task'] = 'question'
    logtrig.loc[(logtrig['VAL']>=2) & (logtrig['VAL']<=3), 'task'] = 'recal'
    logtrig.loc[logtrig['VAL']>20, 'task'] = 'localizer'
    logtrig.loc[logtrig['VAL']==25, 'task'] = 'resting'

    cols_logtrig=['identifier','task','event_type', 'eeg_sample',  'eye_sample_est', 'duration_sec'] # useful subset of cols
    task_events = logtrig[cols_logtrig].copy()
    task_events['description'] = task_events['event_type'] + '|task:'  +task_events['task'] + '|identifier:' + task_events['identifier']
    task_events['latency_sec'] = task_events['eeg_sample'] / EEG.info['sfreq']


    ##load orig eyetraker events from msg files
    def read_eyetracker_events(event_type):
        files = glob.glob(os.path.join(dir_raw, pID, 'Unpacked', f'EML*{event_type}.csv'))
        events = pd.concat([pd.read_csv(file) for file in files], ignore_index=True)
        events=events.rename(columns={'duration':'duration_samples','tStart':'latency_samples'})
        events['latency_sec'] = events['latency_samples'] / EEG.info['sfreq']  # convert to seconds
        events['duration_sec'] = (events['duration_samples']) / EEG.info['sfreq'] # convert to seconds
        events['event_type'] = event_type + '_' + events['eye']
        return events

    blinks = read_eyetracker_events('Blink')
    # , 'xEnd', 'yEnd', 'ampDeg', 'vPeak', # saccade info
    saccades = read_eyetracker_events('Saccade').rename(columns={'xStart':'sac_xStart', 'yStart':'sac_yStart', 'xEnd':'sac_xEnd', 'yEnd':'sac_yEnd', 'ampDeg':'sac_ampDeg', 'vPeak':'sac_vPeak'})
    fixations = read_eyetracker_events('Fixation').rename(columns={'xAvg':'fix_xAvg', 'yAvg':'fix_yAvg', 'pupilAvg':'fix_pupilAvg'})
    eye_events = pd.concat([blinks, saccades, fixations], ignore_index=True)
    eye_events = eye_events.dropna(subset=['latency_sec']).sort_values('latency_sec')
    if len(eye_events)==0:
        print(f"No eyetracker events for {pID}")
        continue

    ##interpolate all eye event timestamps to get closest eeg sample
    # Select rows with non-NaN values for both eeg and eyetracker samples
    ix = (~task_events['eye_sample_est'].isna() & ~task_events['eeg_sample'].isna() &
        (task_events['eeg_sample'] < len(EEG)) &
        ~task_events['identifier'].str.contains('Recal'))

    F = CubicSpline(task_events.loc[ix, 'eye_sample_est'], task_events.loc[ix, 'eeg_sample'])

    eye_events['eeg_sample'] = np.round(F(eye_events['latency_samples'])).astype(int)

    # # Plot the interpolated fixation start times
    # plt.plot(eye_events['eeg_sample'], eye_events['latency_samples'])
    # plt.xlabel('EEG Start Time')
    # plt.ylabel('Eye Tracker Start Time')
    # plt.title('Interpolated Fixation Start Times')
    # plt.show()

    ##tidy up eye_events
    eye_events['latency_sec'] = eye_events['eeg_sample'] / EEG.info['sfreq']
    eye_events = eye_events[(eye_events['latency_sec'] >= 0) & (eye_events['latency_sec'] + eye_events['duration_sec'] <= len(EEG)/EEG.info['sfreq'])]
    eye_events.drop(columns=['latency_samples', 'duration_samples','tEnd'], inplace=True)
    eye_events['identifier'] = ''
    eye_events['task'] = ''
    # concatenate eye events with task_events, sort by eeg_events and fill in identifier
    # eye_events = pd.concat(task_events, eye_events).sort_values('latency_sec').reset_index(drop=True)
    for i, row in task_events.iterrows():
        sel = (eye_events['latency_sec'] >= row['latency_sec']) & (eye_events['latency_sec'] < row['latency_sec']+row['duration_sec'])
        eye_events.loc[sel, 'identifier'] = row['identifier']
        eye_events.loc[sel, 'task'] = row['task']
    eye_events['description'] = eye_events['event_type'] + '|task:' + eye_events['task']  + '|identifier:' + eye_events['identifier'] # doesnt work if any are NA

    ##add in new fixations (w IAs)
    new_fixations = fix_df[fix_df['pID']==pID].copy()
    new_fixations['event_type'] = 'Fixation_R-reparsed'
    # remove extracols
    new_fixations = new_fixations[['pID','event_type', 'identifier','eye', 'latency_samples','duration_samples','fix_pageIndex','IA_ID', 'IA_LABEL','fix_pupilAvg', 'INBOUND_SAC_AMPLITUDE', 'INBOUND_SAC_ANGLE', 'INBOUND_SAC_AVG_VELOCITY', 'INBOUND_SAC_DURATION']]
    new_fixations = new_fixations.merge(task_events[['identifier','task', 'eeg_sample']], on='identifier', how='left')
    new_fixations['eeg_sample'] = new_fixations['latency_samples']/GAZE_SRATE*EEG.info['sfreq'] + new_fixations['eeg_sample'] # add task start time in eeg samples to fixation samples since start of task
    # WARNING thsi assumes eeg and eyetracker have same sample rate (TODO: u can update this to be more general)
    new_fixations['duration_sec'] = new_fixations['duration_samples']/GAZE_SRATE # sec
    new_fixations['description'] = 'Fixation_R-reparsed' + '|task:' + new_fixations['task']  +'|identifier:' + new_fixations['identifier'] + '|fix_pageIndex:' + new_fixations["fix_pageIndex"].astype(str) + '|IA_ID:'+  new_fixations["IA_ID"].astype(str)
    new_fixations['latency_sec'] = new_fixations['eeg_sample'] / EEG.info['sfreq']
    new_fixations = new_fixations[(new_fixations['latency_sec'] >= 0) & (new_fixations['latency_sec'] + new_fixations['duration_sec'] <= len(EEG)/EEG.info['sfreq'])]
    # annot_fix_new = mne.Annotations(onset=new_fixations['latency_sec'], duration=new_fixations['duration_sec'], description=new_fixations['description'])

    #  Compare reparsed and old fixations, keep old right eye fixations that are after the last reparsed fixation
    old_fixations = eye_events[eye_events['event_type'].str.contains('Fixation_R')]
    if len(old_fixations)==0:
        # use L instead
        print(f"No right eye fixations for {pID}, using left")
        old_fixations = eye_events[eye_events['event_type'].str.contains('Fixation_L')]

    print(f"{len(old_fixations)} fixations before. {len(new_fixations)} reparsed")

    comp = pd.concat([old_fixations, new_fixations]).sort_values(by='eeg_sample')
    new_fixations_final = new_fixations['eeg_sample'].max()
    old_fixations_final = old_fixations['eeg_sample'].max()
    new_fixations_first = new_fixations['eeg_sample'].min()
    old_fixations_first = old_fixations['eeg_sample'].min()
    # remove old fixations from eye_events where they occur in region where repsraed fixations are
    eye_events = eye_events[~((eye_events['event_type'].str.match('Fixation')) & 
                            (eye_events['eeg_sample'] > new_fixations_first) & 
                            (eye_events['eeg_sample'] < new_fixations_final))]
    # old_fixations_keep = eye_events[eye_events['description'].str.contains('Fixation_R') & (eye_events['eeg_sample'] > new_fixations_final)]

    # # Display the comparison DataFrame
    # comp.head(50)

    # # old fixations lack IA alignment, new fixations lack coords! 
    # # try to merge old and new using eeg_sample, they might not match timing exactly
    # comp2 = old_fixations.merge(new_fixations, on='eeg_sample', how='inner', suffixes=('_old', '_new'))
    # print(f"old and new fixations matched on eeg_sample: {len(comp2)} ")
    # 
    eye_events = pd.concat([eye_events, new_fixations]).sort_values(by='latency_sec').dropna(subset=['latency_sec','eeg_sample']).reset_index(drop=True)
    annot_eye = mne.Annotations(onset=eye_events['latency_sec'], duration=eye_events['duration_sec'], description=eye_events['description'])

    # convert to mne.Annotations
    onsets = task_events['latency_sec'] # in seconds! 
    durations = task_events['duration_sec']
    descriptions = task_events['description']
    annot_log = mne.Annotations(onset=onsets, duration=durations, description=descriptions)
    annot = annot_log + annot_eye
    EEG.set_annotations(annot)
    # save out the aligned eyetracker events - keeping only the columns we need
    eye_events=eye_events[['event_type','task','identifier','description','eye', 'eeg_sample', 'latency_sec','duration_sec',
    'sac_xStart', 'sac_yStart', 'sac_xEnd', 'sac_yEnd', 'sac_ampDeg', 'sac_vPeak',
    'fix_xAvg', 'fix_yAvg', 'fix_pupilAvg', # fixation info from old
    'fix_pageIndex', 'IA_ID', 'IA_LABEL', 'INBOUND_SAC_AMPLITUDE', 'INBOUND_SAC_ANGLE', 'INBOUND_SAC_AVG_VELOCITY', 'INBOUND_SAC_DURATION'
    ]]

    eye_events.to_csv(os.path.join(dir_fif, f'{pID}_eyetracker_events.csv'), index=False)
# %%
